<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ye Olde Chat Translator - Transform thy messages into medieval speech</title>

<link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  html {
    overflow-x: hidden;
  }
  
  :root {
    --gold: #d4af37;
    --gold-dark: #b8941f;
    --gold-light: #e5c048;
    --brown-dark: #2c1810;
    --brown-med: #4a3828;
    --brown-light: #8b6f47;
    --parchment: #e8dcc4;
    --parchment-dark: #d4c5a9;
    --shadow: rgba(0, 0, 0, 0.3);
  }

  body {
    font-family: 'Crimson Text', serif;
    background: linear-gradient(135deg, var(--brown-dark) 0%, #1a1006 50%, var(--brown-dark) 100%);
    background-attachment: fixed;
    color: var(--parchment);
    min-height: 100vh;
    line-height: 1.6;
    overflow-x: hidden;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     HERO HEADER
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .hero {
    text-align: center;
    padding: 60px 20px 40px;
    background: linear-gradient(180deg, rgba(44,24,16,0.9) 0%, rgba(26,16,6,0.7) 100%);
    border-bottom: 4px double var(--gold);
    position: relative;
    overflow: hidden;
  }

  .hero h1 {
    font-family: 'UnifrakturMaguntia', cursive;
    font-size: clamp(2rem, 6vw, 3.5rem);
    color: var(--gold);
    margin-bottom: 15px;
    text-shadow: 3px 3px 6px var(--shadow);
    letter-spacing: 2px;
  }

  .hero .subtitle {
    font-size: clamp(1rem, 3vw, 1.3rem);
    color: var(--parchment-dark);
    font-style: italic;
    margin-bottom: 10px;
  }

  .hero .tagline {
    font-size: clamp(0.85rem, 2.5vw, 1rem);
    color: var(--brown-light);
    max-width: 600px;
    margin: 0 auto;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MAIN CONTAINER - Responsive Grid
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
    overflow: hidden;
  }

  .grid-layout {
    display: grid;
    grid-template-columns: 1fr;
    gap: 20px;
    margin-top: 30px;
  }

  @media (min-width: 768px) {
    .grid-layout {
      grid-template-columns: 1fr 1fr;
      gap: 30px;
    }
  }

  @media (min-width: 1200px) {
    .grid-layout {
      grid-template-columns: 1.2fr 1fr;
      gap: 40px;
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     CARDS
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .card {
    background: rgba(44,24,16,0.95);
    border: 1px solid #8b6f47;
    padding: 30px;
    margin-bottom: 20px;
  }

  .card-title {
    font-family: 'Cinzel', serif;
    font-size: clamp(1.3rem, 3vw, 1.8rem);
    color: var(--gold);
    margin-bottom: 20px;
    text-align: center;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FORM CONTROLS
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .form-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 15px;
    margin: 20px 0;
  }

  @media (min-width: 640px) {
    .form-grid {
      grid-template-columns: 1fr 1fr;
    }
  }

  .form-field label {
    display: block;
    font-family: 'Cinzel', serif;
    font-size: clamp(0.85rem, 2vw, 0.95rem);
    color: var(--gold);
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  select, textarea {
    width: 100%;
    background: rgba(26,16,6,0.8);
    color: var(--parchment);
    border: 2px solid var(--brown-light);
    border-radius: 4px;
    padding: 12px;
    font-family: 'Crimson Text', serif;
    font-size: clamp(0.9rem, 2vw, 1rem);
    transition: all 0.3s ease;
  }

  select:focus, textarea:focus {
    outline: none;
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(212,175,55,0.3);
  }

  textarea {
    min-height: 200px;
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
    line-height: 1.5;
    resize: vertical;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     UPLOAD ZONE
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .upload-zone {
    border: 2px solid var(--brown-light);
    padding: 40px 20px;
    text-align: center;
    cursor: pointer;
    background: rgba(26,16,6,0.4);
    transition: all 0.3s ease;
  }

  .upload-zone:hover {
    border-color: var(--gold);
    background: rgba(212,175,55,0.1);
  }

  .upload-icon {
    font-size: 3rem;
    margin-bottom: 10px;
  }

  .upload-text {
    font-family: 'Cinzel', serif;
    font-size: 1.2rem;
    color: var(--gold);
    margin-bottom: 5px;
  }

  .upload-subtext {
    color: var(--brown-light);
    font-size: 0.9rem;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     BUTTONS
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .btn-group {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
    margin-top: 20px;
  }

  @media (min-width: 640px) {
    .btn-group {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (min-width: 1024px) {
    .btn-group {
      grid-template-columns: repeat(4, 1fr);
    }
  }

  button {
    padding: clamp(12px, 2vw, 16px) 20px;
    font-family: 'Cinzel', serif;
    font-size: clamp(0.85rem, 2vw, 1rem);
    font-weight: 600;
    background: linear-gradient(135deg, var(--brown-med) 0%, #3a2818 100%);
    color: var(--parchment);
    border: 2px solid var(--gold);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  button:hover {
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: var(--brown-dark);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(212,175,55,0.4);
  }

  button:active {
    transform: translateY(0);
  }

  .btn-primary {
    grid-column: 1 / -1;
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: var(--brown-dark);
    font-size: clamp(1rem, 2.5vw, 1.2rem);
    padding: clamp(14px, 3vw, 18px);
  }

  .btn-primary:hover {
    background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold) 100%);
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     STATUS & HINTS
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .status {
    margin-top: 15px;
    padding: 12px;
    border-radius: 4px;
    text-align: center;
    font-size: clamp(0.9rem, 2vw, 1rem);
    display: none;
    white-space: pre-wrap;
    line-height: 1.6;
  }

  .status.show {
    display: block;
  }

  .status.error {
    background: rgba(244,67,54,0.2);
    border: 2px solid #f44336;
    color: #ff6b6b;
  }

  .status.success {
    background: rgba(76,175,80,0.2);
    border: 2px solid #4caf50;
    color: #90ee90;
  }

  .status.info {
    background: rgba(212,175,55,0.2);
    border: 2px solid var(--gold);
    color: var(--gold-light);
  }

  .hint {
    margin-top: 15px;
    padding: 15px;
    background: rgba(212,175,55,0.1);
    border-left: 4px solid var(--gold);
    border-radius: 4px;
    font-size: clamp(0.85rem, 2vw, 0.95rem);
    color: var(--parchment-dark);
    line-height: 1.7;
  }

  .hint strong {
    color: var(--gold);
  }

  .detected-lang {
    margin-top: 15px;
    padding: 12px;
    background: rgba(212,175,55,0.2);
    border: 2px solid var(--gold);
    border-radius: 4px;
    text-align: center;
    font-size: clamp(0.9rem, 2vw, 1rem);
    display: none;
  }

  .detected-lang.show {
    display: block;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     PHONE MOCKUP - Multi-Platform Styles
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .phone-mockup {
    background: #fff;
    border-radius: clamp(20px, 4vw, 30px);
    box-shadow: 0 15px 50px rgba(0,0,0,0.6);
    overflow: hidden;
    display: none;
    margin: 0 auto;
    max-width: 100%;
  }

  .phone-mockup.show {
    display: block;
  }

  @media (min-width: 768px) {
    .phone-mockup {
      max-width: 450px;
    }
  }

  /* === WHATSAPP STYLE (DEFAULT) === */
  .phone-mockup .phone-header {
    background: #075e54;
    color: #fff;
    padding: clamp(12px, 3vw, 18px);
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .phone-mockup .phone-avatar {
    width: clamp(35px, 8vw, 45px);
    height: clamp(35px, 8vw, 45px);
    background: #25d366;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: clamp(1rem, 3vw, 1.3rem);
    flex-shrink: 0;
  }

  .phone-mockup .phone-name {
    font-weight: 600;
    font-size: clamp(0.95rem, 2.5vw, 1.1rem);
  }

  .phone-mockup .chat-area {
    background: #ece5dd;
    padding: clamp(15px, 3vw, 25px) clamp(10px, 2vw, 15px);
    min-height: clamp(400px, 60vh, 600px);
    max-height: 70vh;
    overflow-y: auto;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  .phone-mockup .chat-bubble {
    max-width: 80%;
    margin: 8px 0;
    padding: clamp(8px, 2vw, 12px) clamp(10px, 2.5vw, 14px);
    border-radius: 8px;
    word-wrap: break-word;
    font-size: clamp(0.9rem, 2vw, 1rem);
    line-height: 1.5;
    clear: both;
  }

  .phone-mockup .chat-bubble.them {
    background: #fff;
    float: left;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }

  .phone-mockup .chat-bubble.me {
    background: #dcf8c6;
    float: right;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }

  /* === TELEGRAM STYLE === */
  .phone-mockup.telegram .phone-header {
    background: #517DA2;
  }

  .phone-mockup.telegram .phone-avatar {
    background: #fff;
    color: #517DA2;
  }

  .phone-mockup.telegram .chat-area {
    background: #ffffff;
  }

  .phone-mockup.telegram .chat-bubble.them {
    background: #ffffff;
    border-radius: 12px 12px 12px 2px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
  }

  .phone-mockup.telegram .chat-bubble.me {
    background: #EEFFDE;
    border-radius: 12px 12px 2px 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
  }

  /* === MESSENGER STYLE === */
  .phone-mockup.messenger .phone-header {
    background: #0084FF;
  }

  .phone-mockup.messenger .phone-avatar {
    background: #fff;
    color: #0084FF;
  }

  .phone-mockup.messenger .chat-area {
    background: #ffffff;
  }

  .phone-mockup.messenger .chat-bubble.them {
    background: #E4E6EB;
    color: #000;
    border-radius: 20px;
  }

  .phone-mockup.messenger .chat-bubble.me {
    background: #0084FF;
    color: #fff;
    border-radius: 20px;
  }

  /* === INSTAGRAM STYLE === */
  .phone-mockup.instagram .phone-header {
    background: linear-gradient(45deg, #f09433 0%,#e6683c 25%,#dc2743 50%,#cc2366 75%,#bc1888 100%);
  }

  .phone-mockup.instagram .phone-avatar {
    background: #fff;
    color: #000;
  }

  .phone-mockup.instagram .chat-area {
    background: #ffffff;
  }

  .phone-mockup.instagram .chat-bubble.them {
    background: #EFEFEF;
    color: #000;
    border-radius: 22px;
  }

  .phone-mockup.instagram .chat-bubble.me {
    background: #3797F0;
    color: #fff;
    border-radius: 22px;
  }

  /* === SNAPCHAT STYLE === */
  .phone-mockup.snapchat .phone-header {
    background: #FFFC00;
    color: #000;
  }

  .phone-mockup.snapchat .phone-avatar {
    background: #000;
    color: #FFFC00;
  }

  .phone-mockup.snapchat .chat-area {
    background: #ffffff;
  }

  .phone-mockup.snapchat .chat-bubble.them {
    background: #FF5E3A;
    color: #fff;
    border-radius: 20px;
  }

  .phone-mockup.snapchat .chat-bubble.me {
    background: #0EADFF;
    color: #fff;
    border-radius: 20px;
  }

  /* === iMESSAGE STYLE === */
  .phone-mockup.imessage .phone-header {
    background: #f5f5f7;
    color: #000;
    border-bottom: 1px solid #d1d1d6;
  }

  .phone-mockup.imessage .phone-avatar {
    background: #007AFF;
    color: #fff;
  }

  .phone-mockup.imessage .chat-area {
    background: #ffffff;
  }

  .phone-mockup.imessage .chat-bubble.them {
    background: #E5E5EA;
    color: #000;
    border-radius: 18px;
  }

  .phone-mockup.imessage .chat-bubble.me {
    background: #007AFF;
    color: #fff;
    border-radius: 18px;
  }

  /* === DISCORD STYLE === */
  .phone-mockup.discord .phone-header {
    background: #5865F2;
  }

  .phone-mockup.discord .phone-avatar {
    background: #fff;
    color: #5865F2;
  }

  .phone-mockup.discord .chat-area {
    background: #36393f;
  }

  .phone-mockup.discord .chat-bubble {
    background: transparent;
    border-radius: 0;
    padding: 8px 12px;
    max-width: 100%;
    margin: 2px 0;
    box-shadow: none;
  }

  .phone-mockup.discord .chat-bubble.them,
  .phone-mockup.discord .chat-bubble.me {
    background: transparent;
    float: none;
    color: #dcddde;
  }

  .phone-mockup.discord .chat-bubble:hover {
    background: rgba(79, 84, 92, 0.16);
  }

  /* === REDDIT STYLE === */
  .phone-mockup.reddit .phone-header {
    background: #FF4500;
  }

  .phone-mockup.reddit .phone-avatar {
    background: #fff;
    color: #FF4500;
  }

  .phone-mockup.reddit .chat-area {
    background: #DAE0E6;
  }

  .phone-mockup.reddit .chat-bubble {
    background: #fff;
    border-radius: 4px;
    border-left: 3px solid #ccc;
    padding: 12px;
    max-width: 100%;
    margin: 12px 0;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    float: none;
  }

  .phone-mockup.reddit .chat-bubble.them {
    border-left-color: #FF4500;
  }

  .phone-mockup.reddit .chat-bubble.me {
    border-left-color: #0079D3;
  }

  /* === TIKTOK STYLE === */
  .phone-mockup.tiktok .phone-header {
    background: #000000;
  }

  .phone-mockup.tiktok .phone-avatar {
    background: #FE2C55;
    color: #fff;
  }

  .phone-mockup.tiktok .chat-area {
    background: #ffffff;
  }

  .phone-mockup.tiktok .chat-bubble {
    background: #F1F1F2;
    border-radius: 8px;
    padding: 12px;
    max-width: 100%;
    margin: 8px 0;
    float: none;
  }

  .phone-mockup.tiktok .chat-bubble.them {
    background: #F1F1F2;
  }

  .phone-mockup.tiktok .chat-bubble.me {
    background: #FE2C55;
    color: #fff;
  }

  /* === WECHAT STYLE === */
  .phone-mockup.wechat .phone-header {
    background: #09B83E;
  }

  .phone-mockup.wechat .phone-avatar {
    background: #fff;
    color: #09B83E;
  }

  .phone-mockup.wechat .chat-area {
    background: #EDEDED;
  }

  .phone-mockup.wechat .chat-bubble.them {
    background: #fff;
    border-radius: 6px;
  }

  .phone-mockup.wechat .chat-bubble.me {
    background: #95EC69;
    border-radius: 6px;
  }

  .chat-bubble .text {
    color: #000;
    margin-bottom: 3px;
  }

  .phone-mockup.messenger .chat-bubble.me .text,
  .phone-mockup.instagram .chat-bubble.me .text,
  .phone-mockup.snapchat .chat-bubble .text,
  .phone-mockup.tiktok .chat-bubble.me .text,
  .phone-mockup.imessage .chat-bubble.me .text {
    color: #fff;
  }

  .phone-mockup.discord .chat-bubble .text {
    color: #dcddde;
  }

  .chat-bubble .time {
    font-size: 0.7rem;
    color: rgba(102, 119, 129, 0.8);
    text-align: right;
    margin-top: 4px;
  }

  .phone-mockup.messenger .chat-bubble.me .time,
  .phone-mockup.instagram .chat-bubble.me .time,
  .phone-mockup.snapchat .chat-bubble .time,
  .phone-mockup.tiktok .chat-bubble.me .time,
  .phone-mockup.imessage .chat-bubble.me .time {
    color: rgba(255, 255, 255, 0.8);
  }

  .phone-mockup.discord .chat-bubble .time {
    color: #72767d;
    font-size: 0.65rem;
  }

  .chat-area::after {
    content: '';
    display: table;
    clear: both;
  }

  .phone-footer {
    background: #f0f0f0;
    padding: clamp(10px, 2vw, 15px);
    text-align: center;
    font-size: clamp(0.75rem, 1.8vw, 0.85rem);
    color: #667781;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     FOOTER WITH BUY ME A COFFEE
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .site-footer {
    text-align: center;
    margin-top: clamp(40px, 8vw, 80px);
    padding: clamp(30px, 6vw, 50px) 20px;
    border-top: 3px double var(--gold);
    background: linear-gradient(180deg, transparent 0%, rgba(44,24,16,0.5) 100%);
  }

  .site-footer h2 {
    font-family: 'UnifrakturMaguntia', cursive;
    font-size: clamp(1.5rem, 4vw, 2rem);
    color: var(--gold);
    margin-bottom: 15px;
  }

  .site-footer p {
    font-style: italic;
    color: var(--parchment-dark);
    line-height: 1.8;
    margin: 10px 0;
    font-size: clamp(0.9rem, 2vw, 1.05rem);
  }

  .coffee-btn {
    display: inline-block;
    padding: clamp(12px, 2.5vw, 16px) clamp(20px, 4vw, 32px);
    margin-top: 20px;
    background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dark) 100%);
    color: var(--brown-dark);
    text-decoration: none;
    border: 2px solid var(--gold);
    border-radius: 6px;
    font-family: 'Cinzel', serif;
    font-weight: 600;
    font-size: clamp(0.9rem, 2vw, 1.05rem);
    letter-spacing: 1px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(212,175,55,0.3);
  }

  .coffee-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(212,175,55,0.5);
    background: linear-gradient(135deg, var(--gold-light) 0%, var(--gold) 100%);
  }

  .footer-credit {
    margin-top: 30px;
    font-size: clamp(0.8rem, 1.8vw, 0.9rem);
    color: #6b5d4f;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MOBILE OPTIMIZATIONS
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  @media (max-width: 640px) {
    .hero {
      padding: 40px 15px 30px;
    }

    .container {
      padding: 15px;
    }

    .card {
      padding: 20px;
    }

    .upload-zone {
      padding: 40px 15px;
    }

    button {
      width: 100%;
    }
  }

  /* Tablet specific */
  @media (min-width: 768px) and (max-width: 1023px) {
    .grid-layout {
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
    }
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     ANIMATIONS
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .fade-in {
    animation: fadeIn 0.6s ease;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     LOADING SPINNER
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .spinner {
    border: 4px solid rgba(212,175,55,0.2);
    border-top: 4px solid var(--gold);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
    display: none;
  }

  .spinner.show {
    display: block;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>
</head>

<body>

<!-- HERO HEADER -->
<div class="hero">
  <h1>âš” Ye Olde Chat Translator âš”</h1>
  <p class="subtitle">Transform thy messages into medieval speech</p>
  <p class="tagline">
    Works with ANY chat app â€¢ WhatsApp â€¢ Telegram â€¢ Messenger â€¢ Instagram â€¢ Reddit â€¢ Snapchat<br>
    From "hey bro" to "Hail, good sir" â€¢ A scribe's tool for the digital age
  </p>
</div>

<div class="container">
  <div class="grid-layout">
    
    <!-- LEFT COLUMN: INPUT -->
    <div class="card fade-in">
      <h2 class="card-title">ğŸ“œ Input Thy Chat</h2>
      
      <!-- Upload Screenshot Section -->
      <div style="margin-bottom:25px;">
        <div class="upload-zone" onclick="document.getElementById('fileInput').click()">
          <input id="fileInput" type="file" accept="image/*" style="display:none;">
          <div class="upload-icon">ğŸ“¸</div>
          <div class="upload-text">Upload Screenshot</div>
          <div class="upload-subtext">Click to select image</div>
        </div>
        
        <!-- Image Preview (hidden by default) -->
        <div id="imagePreview" style="display:none;margin-top:15px;text-align:center;">
          <img id="previewImg" alt="Preview" style="max-width:100%;max-height:300px;border:1px solid #8b6f47;margin-bottom:10px;">
          <div style="display:flex;gap:10px;">
            <button onclick="extractText()" style="flex:1;">ğŸ“ Extract Text (OCR)</button>
            <button onclick="removeImage()" style="flex:1;background:#6b5d4f;">âŒ Remove</button>
          </div>
        </div>
      </div>
      
      <!-- Language Settings -->
      <div class="form-grid">
        <div class="form-field">
          <label>Chat Language</label>
          <select id="sourceLang">
            <option value="auto" selected>ğŸ” Auto-Detect</option>
            <option value="nl">Dutch â†’ Medieval</option>
            <option value="en">English â†’ Medieval</option>
          </select>
        </div>
        <div class="form-field">
          <label>Conversation Pattern</label>
          <select id="conversationPattern">
            <option value="alternate-them" selected>Alternating (starts with them)</option>
            <option value="alternate-me">Alternating (starts with me)</option>
            <option value="all-them">All messages from them</option>
            <option value="all-me">All messages from me</option>
          </select>
        </div>
      </div>
      
      <div class="form-grid">
        <div class="form-field">
          <label>Output Style</label>
          <select id="platformStyle">
            <option value="whatsapp" selected>WhatsApp</option>
            <option value="telegram">Telegram</option>
            <option value="messenger">Messenger</option>
            <option value="instagram">Instagram</option>
            <option value="snapchat">Snapchat</option>
            <option value="tiktok">TikTok</option>
            <option value="wechat">WeChat</option>
            <option value="imessage">iMessage</option>
            <option value="discord">Discord</option>
            <option value="reddit">Reddit</option>
          </select>
        </div>
        <div class="form-field">
          <label>Parsing Mode</label>
          <select id="parseMode">
            <option value="visual" selected>Visual (Screenshots)</option>
            <option value="smart">Smart (Timestamps)</option>
            <option value="simple">Simple (Basic)</option>
          </select>
        </div>
      </div>

      <!-- Detection Feedback -->
      <div class="detected-lang" id="detectedLang"></div>

      <!-- Hint -->
      <div class="hint">
        <strong>ğŸ¯ Auto-Platform Detection:</strong> Upload a screenshot and the app <b>automatically detects</b> which chat app it's from (WhatsApp, Messenger, Reddit, etc.) and matches the output style! 
        <br>
        <strong>ğŸ“¤ Input = Output:</strong> Reddit screenshot â†’ Reddit style output | Messenger â†’ Messenger style | etc.
        <br><br>
        <strong>ğŸ’¬ Conversation Pattern:</strong> Auto-detects bubble positions (left/right) or manually adjust:
        <ul style="margin:8px 0 8px 20px;padding:0;">
          <li><b>Alternating (starts with them)</b> - Left side first</li>
          <li><b>Alternating (starts with me)</b> - Right side first</li>
        </ul>
      </div>

      <!-- Text Input -->
      <div class="form-field" style="margin-top: 20px;">
        <label>Paste Your Chat Text</label>
        <textarea id="chatInput" placeholder="Paste your WhatsApp chat here!

BEST FORMAT (each message on new line with timestamp):
4:02 hey what's up
4:03 not much, you?
4:03 same, wanna hang?
4:04 yeah sure!

OR paste directly from WhatsApp - the app will try to parse it!

TIP: For best results, copy text from WhatsApp (not screenshot OCR)"></textarea>
        <div style="margin-top:10px;padding:8px;background:rgba(76,175,80,0.2);border-left:4px solid #4caf50;font-size:0.85em;color:#90ee90;">
          ğŸ’¡ <b>Best Results:</b> Copy chat text directly from WhatsApp instead of using screenshots. Each message with timestamp will become a separate bubble!
        </div>
      </div>

      <!-- Spinner -->
      <div class="spinner" id="spinner"></div>

      <!-- Status -->
      <div class="status" id="status"></div>

      <!-- Action Buttons -->
      <div class="btn-group">
        <button class="btn-primary" onclick="translateChat()">âš” TRANSLATE TO MEDIEVAL âš”</button>
        <button onclick="downloadAsImage()">ğŸ“¸ Download Screenshot</button>
        <button onclick="copyMedieval()">ğŸ“‹ Copy Text</button>
        <button onclick="downloadMedieval()">ğŸ“„ Download .txt</button>
      </div>
    </div>

    <!-- RIGHT COLUMN: OUTPUT -->
    <div class="card fade-in" style="animation-delay: 0.2s;">
      <h2 class="card-title">ğŸ“± Medieval Output</h2>
      
      <div class="phone-mockup" id="phoneMockup">
        <div class="phone-header">
          <div class="phone-avatar">M</div>
          <div class="phone-name">Medieval Chat</div>
        </div>
        <div class="chat-area" id="chatArea">
          <p style="text-align:center;color:#667781;padding:40px 20px;font-style:italic;">
            Thy translated messages shall appear here...<br><br>
            âœ¨ Upload or paste a chat, then click Translate âœ¨
          </p>
        </div>
        <div class="phone-footer">Ye Olde Chat Translator - Works with any chat app!</div>
      </div>

      <div class="hint" style="margin-top: 20px;">
        <strong>ğŸ“± Visual Output:</strong> Your chat appears in WhatsApp style with medieval text. Download as PNG to share on social media!
      </div>
    </div>

  </div>
</div>

<!-- FOOTER -->
<div class="site-footer">
  <h2>âš” Ye Olde Chat Translator âš”</h2>
  <p>
    A humble scribe's work, freely given unto thee.<br>
    If this tool hath brought thee mirth or wonder...
  </p>
  <a href="https://buymeacoffee.com/craftyacorn" target="_blank" class="coffee-btn">
    â˜• My thanks, kind soul - a coffee keeps the quill moving
  </a>
  <p class="footer-credit">
    Made with ancient magic and modern sorcery<br>
    by a wandering scribe
  </p>
</div>

<script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
<script src='https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js'></script>

<script>
  const fileInput = document.getElementById('fileInput');
  const imagePreview = document.getElementById('imagePreview');
  const previewImg = document.getElementById('previewImg');
  const statusEl = document.getElementById('status');
  const chatInput = document.getElementById('chatInput');
  const phoneMockup = document.getElementById('phoneMockup');
  const chatArea = document.getElementById('chatArea');
  const detectedLang = document.getElementById('detectedLang');
  const spinner = document.getElementById('spinner');

  let currentMessages = [];

  // Initialize Tesseract Worker properly to avoid blob errors
  // Note: In some test environments (like claudeusercontent.com), 
  // OCR may fail due to browser security restrictions.
  // It WILL work on your deployed website (Netlify, etc.)

  // File handling
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    if (!file.type.startsWith('image/')) {
      setStatus('Please select an image file.', 'error');
      return;
    }
    const reader = new FileReader();
    reader.onload = (ev) => {
      previewImg.src = ev.target.result;
      imagePreview.style.display = 'block';
      
      // Automatically detect bubble positions
      detectBubblePositions(ev.target.result);
    };
    reader.readAsDataURL(file);
  });

  // AUTOMATIC BUBBLE POSITION DETECTION
  function detectBubblePositions(imageData) {
    const img = new Image();
    img.onload = function() {
      try {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        
        // Sample colors from left and right sides
        const width = canvas.width;
        const height = canvas.height;
        const leftThird = width / 3;
        const rightThird = (width * 2) / 3;
        
        let leftBubbles = 0;
        let rightBubbles = 0;
        
        // Sample multiple rows to detect bubbles
        for (let y = height * 0.2; y < height * 0.8; y += 20) {
          // Check left side (0 to leftThird)
          const leftData = ctx.getImageData(leftThird / 2, y, 1, 1).data;
          const leftBrightness = (leftData[0] + leftData[1] + leftData[2]) / 3;
          
          // Check right side (rightThird to width)
          const rightData = ctx.getImageData(rightThird + (width - rightThird) / 2, y, 1, 1).data;
          const rightBrightness = (rightData[0] + rightData[1] + rightData[2]) / 3;
          
          // Bubbles are typically white or colored (brighter than background)
          if (leftBrightness > 180) leftBubbles++;
          if (rightBrightness > 180) rightBubbles++;
        }
        
        // Determine pattern based on which side has more bubbles
        const patternSelect = document.getElementById('conversationPattern');
        
        if (leftBubbles > rightBubbles * 1.5) {
          // Mostly left side - they sent most messages
          patternSelect.value = 'alternate-them';
          console.log('ğŸ¨ Detected: Messages mostly on LEFT - Pattern: starts with them');
        } else if (rightBubbles > leftBubbles * 1.5) {
          // Mostly right side - I sent most messages
          patternSelect.value = 'alternate-me';
          console.log('ğŸ¨ Detected: Messages mostly on RIGHT - Pattern: starts with me');
        } else {
          // Mixed or unclear - keep default
          console.log('ğŸ¨ Mixed pattern detected - using default alternating');
        }
        
        setStatus('ğŸ“¸ Image loaded! Bubble positions auto-detected. Click Extract Text.', 'success');
        
      } catch (error) {
        console.log('Could not analyze image layout:', error);
        setStatus('ğŸ“¸ Image loaded! Click Extract Text.', 'success');
      }
    };
    img.src = imageData;
  }

  // VISUAL BUBBLE DETECTION - Analyze image to find actual bubble boundaries!
  async function detectVisualBubbles(imageDataUrl) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = function() {
        try {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          
          const width = canvas.width;
          const height = canvas.height;
          
          // Find bubbles by scanning for bright rectangular regions
          const bubbles = [];
          const scannedRows = new Set();
          
          // Scan in vertical steps
          for (let y = Math.floor(height * 0.15); y < height * 0.85; y += 25) {
            const rowId = Math.floor(y / 40);
            if (scannedRows.has(rowId)) continue;
            scannedRows.add(rowId);
            
            // Check left and right sides for bubbles
            const leftPixel = ctx.getImageData(width * 0.15, y, 1, 1).data;
            const rightPixel = ctx.getImageData(width * 0.75, y, 1, 1).data;
            
            const leftBright = (leftPixel[0] + leftPixel[1] + leftPixel[2]) / 3;
            const rightBright = (rightPixel[0] + rightPixel[1] + rightPixel[2]) / 3;
            
            const leftHasBubble = leftBright > 180; // Light colored
            const rightHasBubble = rightBright > 180 || rightPixel[2] > 150; // Light or blue
            
            if (leftHasBubble || rightHasBubble) {
              const side = leftHasBubble ? 'left' : 'right';
              bubbles.push({
                x: side === 'left' ? width * 0.05 : width * 0.4,
                y: y - 25,
                width: width * 0.5,
                height: 70,
                side: side,
                centerY: y
              });
            }
          }
          
          // Merge nearby bubbles on same side
          const merged = [];
          bubbles.sort((a, b) => a.centerY - b.centerY);
          
          for (let bubble of bubbles) {
            const nearby = merged.find(m => 
              m.side === bubble.side && 
              Math.abs(m.centerY - bubble.centerY) < 55
            );
            
            if (nearby) {
              nearby.y = Math.min(nearby.y, bubble.y);
              nearby.height = Math.max(nearby.height, bubble.height + 15);
              nearby.centerY = (nearby.centerY + bubble.centerY) / 2;
            } else {
              merged.push(bubble);
            }
          }
          
          console.log('ğŸ¯ Visually detected', merged.length, 'message bubbles');
          resolve(merged);
        } catch (error) {
          console.log('Bubble detection failed:', error);
          resolve([]);
        }
      };
      img.onerror = () => resolve([]);
      img.src = imageDataUrl;
    });
  }

  function removeImage() {
    fileInput.value = '';
    imagePreview.style.display = 'none';
    previewImg.src = '';
  }

  async function extractText() {
    if (!previewImg.src) {
      setStatus('No image to extract from.', 'error');
      return;
    }

    setStatus('ğŸ” Analyzing image layout...', 'info');
    spinner.classList.add('show');

    try {
      // Quick visual scan to count bubbles (doesn't affect OCR quality)
      const bubbles = await detectVisualBubbles(previewImg.src);
      
      if (bubbles && bubbles.length > 0) {
        console.log('ğŸ¯ Visual detection found', bubbles.length, 'bubbles');
        window.detectedBubbleCount = bubbles.length;
        
        // Auto-set conversation pattern
        const firstSide = bubbles[0].side;
        const pattern = firstSide === 'left' ? 'alternate-them' : 'alternate-me';
        document.getElementById('conversationPattern').value = pattern;
      } else {
        window.detectedBubbleCount = null;
      }
      
      // Use full-image OCR for best quality
      setStatus('ğŸª¶ Extracting text...', 'info');
      
      const { data: { text } } = await Tesseract.recognize(
        previewImg.src,
        'eng',
        {
          logger: (m) => {
            if (m.status === 'recognizing text') {
              const pct = Math.round(m.progress * 100);
              setStatus(`ğŸª¶ Reading text... ${pct}%`, 'info');
            }
          }
        }
      );
      
      spinner.classList.remove('show');
      
      if (!text || text.trim().length < 10) {
        setStatus('âŒ Could not read enough text.', 'error');
        return;
      }

      chatInput.value = text;
      
      // Auto-detect platform
      const detectedPlatform = detectPlatformFromText(text);
      document.getElementById('platformStyle').value = detectedPlatform;
      
      const lang = detectLanguage(text);
      const langName = lang === 'nl' ? 'Dutch ğŸ‡³ğŸ‡±' : 'English ğŸ‡¬ğŸ‡§';
      const platformEmoji = {
        'whatsapp': 'ğŸ’¬', 'messenger': 'ğŸ’¬', 'instagram': 'ğŸ“·',
        'reddit': 'ğŸ”´', 'telegram': 'âœˆï¸', 'snapchat': 'ğŸ‘»',
        'tiktok': 'ğŸµ', 'wechat': 'ğŸ’š', 'discord': 'ğŸ®', 'imessage': 'ğŸ“±'
      };
      const platformName = detectedPlatform.charAt(0).toUpperCase() + detectedPlatform.slice(1);
      const emoji = platformEmoji[detectedPlatform] || 'ğŸ’¬';
      
      const bubbleInfo = window.detectedBubbleCount ? ` | Found ${window.detectedBubbleCount} bubbles` : '';
      setStatus(`âœ… Extracted! ${emoji} Platform: ${platformName} | ${langName}${bubbleInfo}\nClick TRANSLATE`, 'success');

    } catch (error) {
      console.error('OCR Error:', error);
      spinner.classList.remove('show');
      setStatus('âŒ OCR failed.', 'error');
    }
  }

  function setStatus(msg, type) {
    statusEl.textContent = msg;
    statusEl.className = 'status show ' + (type || 'info');
  }

  // Language Detection
  function detectLanguage(text) {
    const lowerText = text.toLowerCase();
    
    const dutchWords = ['hoi', 'hallo', 'ja', 'nee', 'niet', 'wat', 'een', 'van', 'het', 'de', 'ben', 'bent', 'zijn', 'mijn', 'jouw', 'jij', 'je', 'ook', 'maar', 'dan', 'naar', 'voor', 'met', 'aan', 'op', 'om', 'nu', 'goed', 'kan', 'moet', 'veel', 'meer', 'wel', 'nog', 'dus', 'hier', 'daar', 'deze', 'die', 'bij', 'uit', 'door', 'over', 'zou', 'hebben', 'lekker', 'heb', 'hebt', 'heeft', 'hadden', 'zal', 'waarom', 'omdat', 'misschien', 'eigenlijk', 'gewoon', 'echt', 'heel', 'beetje', 'dag', 'morgen', 'avond', 'gaan', 'doei', 'oke', 'dank', 'alsjeblieft', 'sorry', 'leuk', 'cool'];
    
    const englishWords = ['the', 'and', 'you', 'that', 'this', 'with', 'for', 'not', 'but', 'have', 'from', 'they', 'what', 'about', 'which', 'when', 'make', 'like', 'time', 'know', 'take', 'people', 'your', 'good', 'some', 'could', 'them', 'see', 'other', 'than', 'then', 'now', 'look', 'come', 'over', 'think', 'also', 'back', 'after', 'how', 'our', 'work', 'well', 'way', 'even', 'new', 'want', 'because', 'any', 'give', 'day', 'most', 'going', 'yeah', 'gonna', 'wanna', 'hey', 'bro', 'thanks', 'please', 'okay', 'cool', 'sorry', 'nice'];
    
    let dutchScore = 0, englishScore = 0;
    
    dutchWords.forEach(word => {
      const regex = new RegExp('\\b' + word + '\\b', 'gi');
      const matches = lowerText.match(regex);
      if (matches) dutchScore += matches.length;
    });
    
    englishWords.forEach(word => {
      const regex = new RegExp('\\b' + word + '\\b', 'gi');
      const matches = lowerText.match(regex);
      if (matches) englishScore += matches.length;
    });
    
    return dutchScore > englishScore ? 'nl' : 'en';
  }

  function showDetectedLanguage(lang) {
    detectedLang.innerHTML = lang === 'nl' 
      ? 'ğŸ‡³ğŸ‡± <b>Detected:</b> Dutch (Nederlands) - Translating to Medieval Dutch'
      : 'ğŸ‡¬ğŸ‡§ <b>Detected:</b> English - Translating to Medieval English';
    detectedLang.classList.add('show');
  }

  // Parsing
  function parseImproved(text) {
    const mode = document.getElementById('parseMode').value || 'smart';
    
    if (mode === 'visual') {
      return parseVisual(text);
    }
    
    const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
    return mode === 'simple' ? parseSimple(lines) : parseSmart(lines);
  }

  // PLATFORM DETECTION: Figure out which app the screenshot is from
  function detectPlatform(text) {
    const lower = text.toLowerCase();
    
    // Snapchat indicators
    if (/\b(snap|send a chat)\b/i.test(text) || /^(ME|JANE|YOU)\s*$/im.test(text)) {
      return 'snapchat';
    }
    
    // Instagram indicators
    if (/\d+\s*likes/i.test(text) || /view \d+ more replies/i.test(text) || /reply/i.test(text)) {
      return 'instagram';
    }
    
    // Reddit indicators
    if (/permalink|save|parent|pocket/i.test(text) || /\d+\s*points/i.test(text)) {
      return 'reddit';
    }
    
    // Telegram indicators
    if (/office chat|group chat/i.test(text) || /[ğŸ‘â¤ï¸ğŸ˜‚]\s*\d+/.test(text)) {
      return 'telegram';
    }
    
    // Messenger indicators
    if (/messenger|facebook|reactions/i.test(text) || /\d+\s*members/i.test(text)) {
      return 'messenger';
    }
    
    // WhatsApp indicators (default)
    if (/whatsapp/i.test(text) || /last seen|typing|online/.test(text) || /[<>]\s*\d+/.test(text)) {
      return 'whatsapp';
    }
    
    // Default to WhatsApp style if can't detect
    return 'whatsapp';
  }

  // Detect platform from OCR text (more accurate than image analysis)
  function detectPlatformFromText(text) {
    const lower = text.toLowerCase();
    
    // TIKTOK - very specific markers
    if (/tiktok/i.test(text) || (/\d+[kKmM]?\s*(likes|comments)/i.test(text) && /ago\s*reply/i.test(text))) {
      console.log('ğŸ¨ Detected: TikTok (found: TikTok name or comment format)');
      return 'tiktok';
    }
    if (/@[a-z0-9_]+/i.test(text) && /ago\s*$/im.test(text) && /reply/i.test(text)) {
      console.log('ğŸ¨ Detected: TikTok (found: @ mentions + ago + reply)');
      return 'tiktok';
    }
    
    // SNAPCHAT - improved detection
    if (/snapchat|snap chat/i.test(text) || /^(ME|JANE|YOU|THEM)$/im.test(text)) {
      console.log('ğŸ¨ Detected: Snapchat (found: Snap name or ME/YOU labels)');
      return 'snapchat';
    }
    if (/send a snap|snap map|stories/i.test(text)) {
      console.log('ğŸ¨ Detected: Snapchat (found: Snap UI elements)');
      return 'snapchat';
    }
    
    // WECHAT - specific markers
    if (/wechat|weixin/i.test(text)) {
      console.log('ğŸ¨ Detected: WeChat (found: WeChat name)');
      return 'wechat';
    }
    if (/moments|discover/i.test(text) && /\d{1,2}:\d{2}/.test(text)) {
      console.log('ğŸ¨ Detected: WeChat (found: Moments + timestamp)');
      return 'wechat';
    }
    
    // MESSENGER - very specific markers
    if (/autopia|hey there|active now/i.test(text) && /message$/im.test(text)) {
      console.log('ğŸ¨ Detected: Facebook Messenger (found: Autopia + Message button)');
      return 'messenger';
    }
    if (/^message$/im.test(text) || /active \d+[mh] ago/i.test(text)) {
      console.log('ğŸ¨ Detected: Facebook Messenger (found: Message button or Active status)');
      return 'messenger';
    }
    
    // REDDIT - multiple strong markers
    if (/r\/[a-z]+/i.test(text) && (/upvotes?|opmerkingen|permalink/i.test(text))) {
      console.log('ğŸ¨ Detected: Reddit (found: r/subreddit + upvotes/comments)');
      return 'reddit';
    }
    if (/\d+\s*upvotes?/i.test(text) || (/\d+\s*opmerkingen/i.test(text) && /beantwoorden/i.test(text))) {
      console.log('ğŸ¨ Detected: Reddit (found: upvotes or Dutch Reddit UI)');
      return 'reddit';
    }
    
    // INSTAGRAM
    if (/\d+\s*likes/i.test(text) && /view \d+ more replies/i.test(text)) {
      console.log('ğŸ¨ Detected: Instagram (found: likes + view replies)');
      return 'instagram';
    }
    
    // TELEGRAM
    if (/forwarded from|channel/i.test(text) || /[ğŸ‘â¤ï¸]\s*\d+/.test(text)) {
      console.log('ğŸ¨ Detected: Telegram (found: forwarded/reactions)');
      return 'telegram';
    }
    
    // WHATSAPP - check for WhatsApp-specific patterns
    if (/\d{1,2}:\d{2}\s*[ap]m/i.test(text) && !/message$/im.test(text)) {
      console.log('ğŸ¨ Detected: WhatsApp (found: timestamp format, no other platform markers)');
      return 'whatsapp';
    }
    
    // DEFAULT: If can't detect, use WhatsApp
    console.log('ğŸ¨ Could not detect platform - defaulting to WhatsApp');
    return 'whatsapp';
  }
  // SMART: Use bubble count if available, otherwise split by empty lines
  function parseVisual(text) {
    const messages = [];
    
    // === AGGRESSIVE CLEANUP FIRST ===
    
    // Remove all timestamps in various formats
    text = text.replace(/\d{1,2}:\d{2}\s*(?:AM|PM|am|pm)?/g, '');
    text = text.replace(/^\d{1,2}:\d{2}.*$/gm, ''); // Entire timestamp lines
    
    // Remove OCR garbage patterns
    text = text.replace(/\d{1,2}:\d{2}\s*sl\s*=\s*-/gi, ''); // "13:34 sl = -"
    text = text.replace(/0D\s*0\s*-/gi, ''); // "0D 0 -"
    text = text.replace(/\d+\)\s*[A-Z][a-z]+/g, ''); // "9) Erin"
    text = text.replace(/[\/\\]\s*\\\s*\d+\s*\[=\]/g, ''); // / \ 4 [=]
    
    // Remove URLs and domains
    text = text.replace(/https?:\/\/[^\s]+/gi, '');
    text = text.replace(/[a-z]+\.[a-z]+\.[a-z]+/gi, ''); // craftyacornstudio.github.io
    text = text.replace(/craftyacornstudio/gi, '');
    text = text.replace(/github\.io/gi, '');
    
    // Remove garbage symbols
    text = text.replace(/=\s*\d+\s*\d*/g, ''); // "= 2 29"
    text = text.replace(/\[%/g, '');
    text = text.replace(/Â§/g, 'â¤ï¸'); // Fix hearts
    text = text.replace(/@/g, ''); // OCR heart artifacts
    
    // Remove headers
    text = text.replace(/^(autopia|erin|hey there!?)\s*$/gim, '');
    text = text.replace(/^(AUG|SEP|OCT|NOV|DEC|JAN|FEB)\s+\d+,?\s*\d*/gim, ''); // Date headers
    
    console.log('ğŸ“‹ Cleaned text:', text.substring(0, 200));
    
    // === SMART SPLITTING ===
    
    let chunks = [];
    const bubbleCount = window.detectedBubbleCount;
    
    // Try splitting by empty lines first
    chunks = text.split(/\n\s*\n+/).filter(c => c.trim().length > 0);
    
    console.log('Empty line split gave', chunks.length, 'chunks');
    
    // If we got only 1 chunk, split by sentence endings
    if (chunks.length === 1) {
      console.log('âš ï¸ Only 1 chunk, trying sentence splitting...');
      
      // Split by sentences (. ! ?)
      const lines = text.split(/\n/).filter(l => l.trim().length > 0);
      chunks = [];
      let currentChunk = '';
      
      for (let line of lines) {
        line = line.trim();
        if (line.length < 3) continue;
        
        currentChunk += (currentChunk ? ' ' : '') + line;
        
        // If line ends with punctuation, that's probably end of message
        if (/[.!?]$/.test(line)) {
          if (currentChunk.length > 10) {
            chunks.push(currentChunk);
            currentChunk = '';
          }
        }
      }
      
      // Don't forget last chunk
      if (currentChunk.length > 10) {
        chunks.push(currentChunk);
      }
    }
    
    console.log('âœ… After smart split:', chunks.length, 'chunks');
    
    // Clean each chunk
    for (let chunk of chunks) {
      let content = chunk.trim().replace(/\s+/g, ' ');
      
      // Skip if too short
      if (content.length < 10) continue;
      
      // Skip UI elements
      if (/^(message|reply|like|send)$/i.test(content)) continue;
      
      // Skip if mostly symbols
      const letters = (content.match(/[a-zA-Z]/g) || []).length;
      if (letters < content.length * 0.3) continue;
      
      // Skip lines that are just metadata
      if (/^(at|on)\s+\d{1,2}:\d{2}/i.test(content)) continue;
      
      messages.push({ time: '', content });
    }
    
    console.log('âœ… Final:', messages.length, 'messages');
    return messages;
  }

  function parseSimple(lines) {
    const messages = [];
    for (const line of lines) {
      if (line.length < 2) continue;
      
      // Look for timestamp anywhere in line
      const timeMatch = line.match(/(\d{1,2}[:.]\d{2}\s*(?:AM|PM|am|pm)?)/);
      const time = timeMatch ? timeMatch[1].replace('.', ':') : '';
      
      // Get content (remove timestamp if found)
      let content = line;
      if (time) {
        content = line.replace(timeMatch[0], '').trim().replace(/^[-â€“â€”\s:]+/, '').trim();
      }
      
      if (content.length > 0) {
        messages.push({ time, content });
      }
    }
    return messages;
  }

  function parseSmart(lines) {
    const messages = [];
    
    // First pass: find all timestamps and their positions
    const timestampPattern = /(\d{1,2}[:.]\d{2}\s*(?:AM|PM|am|pm)?)/g;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.length < 2) continue;
      
      // Find ALL timestamps in this line
      const matches = [...line.matchAll(timestampPattern)];
      
      if (matches.length > 0) {
        // Use the FIRST timestamp found (could be anywhere in line)
        const time = matches[0][1].replace('.', ':');
        const timeIndex = matches[0].index;
        
        // Get content AFTER the timestamp
        let content = line.substring(timeIndex + matches[0][0].length).trim();
        
        // Clean up content
        content = content.replace(/^[-â€“â€”\s:]+/, '').trim();
        content = content.replace(/^[A-Za-z\s]+:/, '').trim(); // Remove names like "John:"
        
        // If content is too short, try to get text BEFORE timestamp too
        if (content.length < 3 && timeIndex > 0) {
          const beforeTime = line.substring(0, timeIndex).trim();
          if (beforeTime.length > 0) {
            content = beforeTime + ' ' + content;
          }
        }
        
        // Only add if has actual content
        if (content.length > 0) {
          messages.push({ time, content: content.trim() });
        }
      }
    }
    
    console.log('ğŸ“± Smart parsing found:', messages.length, 'messages');
    return messages;
  }

  // Translation Dictionary (EXPANDED - 350+ words)
  const EN_TRANSLATIONS = {
    'bro': 'good sir', 'mate': 'my fellow', 'my guy': 'my fellow', 'broke': 'hath shattered', 'phone': 'message device', 'texting': 'sending missives', 'computer': 'counting machine', 'how': 'in what wise', 'did': 'didst', 'managed': 'contrived', 'dad': 'sire', 'taking': 'taketh', 'too': 'overmuch', 'get': 'procure', 'soon': 'ere long', 'downloading': 'by fetching', 'whatsapp': 'the WhatsApp scroll', 'i know': 'I know well', 'ong': 'By my troth', 'hes': 'he is', "he's": 'he is', 'going': 'journeying',
    'please': 'prithee', 'welcome': 'salvete', 'hail': 'salvete', 'thank you': 'gramercy', "i'm grateful": 'gramercy', 'thanks': 'gramercy', 'unfortunately': 'alas and alack', 'sadly': 'alas and alack', 'to our misfortune': 'alas and alack', 'goodbye': 'adieu', 'farewell': 'adieu', 'long live': 'viva', 'there you go': 'voila', 'on guard': 'en garde', 'oh': 'egad', 'wow': 'egad', 'oh my god': 'gad', 'disgusting': 'faugh', 'yay': 'huzzah', 'oh yeah': 'huzzah', 'really': 'quotha', 'indeed': 'quotha', 'forsooth': 'quotha', 'damn': 'fie', 'attention': 'oyez', 'hear ye': 'oyez', 'hearken': 'oyez', 'what a shame': 'tut-tut', 'tsk tsk': 'tut-tut',
    'peasant': 'churl', 'slob': 'fustilugs', 'idiot': 'fopdoodle', 'fool': 'fopdoodle', 'dove': 'culver', 'little lamb': 'lambkin', 'good day': 'good morrow', 'be healthy': 'hale be thou', 'how are you': 'how fare ye', 'the root of my heart': 'mine own heart\'s root',
    'stfu': 'hold thy peace', 'shut up': 'hold thy peace', 'be quiet': 'pray thee, be silent', 'wtf': 'what sorcery is this', 'what the': 'what madness dost thou speak', 'omw': 'already am I on the road', 'on my way': 'already am I on the road', 'afaik': 'in the realm of my understanding', 'as far as i know': 'in the realm of my understanding', 'rofl': 'such mirth hath cast me down upon the ground', 'rolling on the floor': 'I am quite slain by thy jest', 'fml': 'alas, I am cursed', 'fuck my life': 'woe is me', 'eta': 'I shall arrive anon', 'when will you arrive': 'my coming is reckoned ere long', 'smh': 'I shake mine head in sorrow', 'shaking my head': 'truly, thou testest my patience', 'omg': 'by God\'s bones', 'brb': 'I shall return anon', 'be right back': 'stay thyself; I step away but briefly', 'idk': 'I wot not', "i don't know": 'this matter is beyond my knowing', 'rip': 'may God rest his soul', 'rest in peace': 'slain. Utterly slain', 'imo': 'to my thinking', 'in my opinion': 'as it seemeth to me', 'gtfo': 'begone', 'get out': 'out of my sight', 'leave': 'get thee hence',
    'chill': 'peace', 'relax': 'softly, now', 'calm down': 'take thy ease', 'cool it': 'cool thy humours', 'nah': 'nay', 'no': 'nay', 'nope': 'I think not', 'yeah': 'aye', 'yes': 'aye', 'yep': 'so it is', 'yup': 'indeed', 'ok': 'very well', 'okay': 'as thou wilt', 'k': 'so be it', 'fr': 'in good sooth', 'for real': 'truly', 'seriously': 'upon my word', 'sus': 'that seemeth amiss', 'suspicious': 'something here doth stink', 'sketch': 'I trust it not', 'bruh': 'good Lord', 'bro wtf': 'mercy', 'dude': 'alas', 'lmao': 'I am slain', 'lmfao': 'I perish of laughter', 'haha': 'dead. Utterly dead', 'bet': 'it is agreed', 'deal': 'done', 'sounds good': 'say no more', 'whatever': 'as it may be', 'whatevs': 'have it thy way',
    'hey': 'Hail', 'hi': 'Greetings', 'hello': 'Well met', 'whats up': 'What tidings', "what's up": 'What tidings', 'gonna': 'shall', 'wanna': 'wisheth to', 'gotta': 'must needs', 'need to': 'must needs', 'want to': 'desire to', 'now': 'presently', 'later': 'anon', 'tomorrow': 'on the morrow', 'today': 'this day', 'tonight': 'this eve', 'you': 'thou', 'your': 'thy', "you're": 'thou art', 'ur': 'thy', 'sorry': 'I beg thy pardon', 'excuse me': 'pardon me'
  };

  const NL_TRANSLATIONS = {
    'hoi': 'Wees gegroet', 'hallo': 'Gegroet', 'hey': 'Heil', 'ja': 'Voorwaar', 'nee': 'Neen', 'ok': 'Het zij zo', 'oke': 'Het zij zo', 'prima': 'Voortreffelijk', 'misschien': 'Wellicht', 'natuurlijk': 'Zekerlijk', 'dank je': 'Ik dank u', 'dankjewel': 'Mijn dank', 'aub': 'Ik bid u', 'haha': 'Ha ha, dat is jolijt', 'lol': 'Ha! Gij doet mij lachen', 'jij': 'gij', 'je': 'gij', 'jou': 'u', 'jouw': 'uw', 'jullie': 'gij allen', 'nu': 'thans', 'later': 'weldra', 'morgen': 'op den morrow', 'vandaag': 'dezen dag', 'vanavond': 'dezen avond', 'cool': 'voortreffelijk', 'leuk': 'aangenaam', 'grappig': 'lachwekkend',
    'alsjeblieft': 'Ik bid u', 'welkom': 'Wees gegroet', 'bedankt': 'Duizend dank', 'dank': 'Mijn dank', 'helaas': 'Ach en wee', 'jammer': 'Wee mij', 'doei': 'Vaarwel', 'dag': 'Adieu', 'tot ziens': 'Ga heen', 'leve': 'Leve', 'kijk': 'Ziehier', 'hier': 'Daar hebt gij het', 'pas op': 'Hoed u', 'let op': 'Wees op uw hoede', 'bah': 'Bah', 'vies': 'Walgelijk', 'hoera': 'Hoera', 'inderdaad': 'Voorwaar', 'echt': 'Zekerlijk', 'schande': 'Schande', 'luister': 'Hoort! Hoort!',
    'bro': 'vriend', 'gast': 'goede man', 'maat': 'kameraad', 'schat': 'hartelief', 'liefje': 'duifje',
    'stfu': 'zwijg', 'hou je bek': 'houd uw mond', 'stil': 'bedwing uw tong', 'wtf': 'wat voor toverij is dit', 'wat': 'welke waanzin spreekt gij', 'omw': 'ik ben reeds onderweg', 'onderweg': 'ik begeef mij op weg', 'afaik': 'voor zover mij bekend', 'voor zover ik weet': 'voor zover mij bekend', 'rofl': 'de lach werpt mij ter aarde', 'lmao': 'ik sterf van het lachen', 'fml': 'wee mij', 'mijn leven': 'het lot keert zich tegen mij', 'eta': 'ik arriveer spoedig', 'hoe laat': 'mijn komst is nabij', 'smh': 'ik schud het hoofd', 'serieus': 'gij beproeft mijn geduld', 'omg': 'bij Gods gebeente', 'oh mijn god': 'hemel en aarde', 'brb': 'ik keer zo terug', 'zo terug': 'wacht mij een ogenblik', 'idk': 'ik weet het niet', 'geen idee': 'het is mij onbekend', 'rip': 'moge hij rusten in vrede', 'rust in vrede': 'gesneuveld', 'imo': 'mijns inziens', 'naar mijn mening': 'naar mijn inzicht', 'gtfo': 'ga heen', 'rot op': 'verdwijn', 'oprotten': 'uit mijn zicht',
    'rustig': 'rustig', 'relax': 'kom tot bedaren', 'kalm': 'koel uw gemoed', 'nee': 'neen', 'niet': 'geenszins', 'yup': 'inderdaad', 'zeker': 'zeker', 'is goed': 'goed', 'echt waar': 'waarlijk', 'eerlijk': 'eerlijk gezegd', 'vaag': 'dat riekt naar bedrog', 'sketchy': 'dat vertrouw ik niet', 'mijn hemel': 'ik ben dit leven moe', 'afgesproken': 'aldus', 'boeit niet': 'het zij zo', 'whatever': 'doe wat gij wilt'
  };

  function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

  function translateOne(content, lang) {
    let translated = String(content || '').toLowerCase();
    const dict = (lang === 'nl') ? NL_TRANSLATIONS : EN_TRANSLATIONS;
    const starters = (lang === 'nl') ? ['Voorwaar, ','In waarheid, ','Ik zeg u, ','Hoort, ','Zie, ',''] : ['Verily, ','Forsooth, ','Marry, ','In sooth, ','Prithee, ','Methinks ','Hark! ','Lo! ',''];
    const enders = (lang === 'nl') ? [', zo waarlijk',', bij mijn eer',', naar mijn weten',', zeg ik u',''] : [', good fellow',', I say',', methinks',', by my troth',', verily',''];

    const keys = Object.keys(dict).sort((a,b)=>b.length-a.length);
    for (const k of keys) {
      const regex = new RegExp('\\b' + escapeRegExp(k) + '\\b', 'gi');
      translated = translated.replace(regex, dict[k]);
    }

    translated = translated
      .replace(/ğŸ˜‚|ğŸ¤£/g, lang==='nl' ? ' (in grote vrolijkheid) ' : ' (showing great mirth) ')
      .replace(/ğŸ˜­/g, lang==='nl' ? ' (in weeklacht) ' : ' (lamenting) ')
      .replace(/â¤ï¸|ğŸ’™|ğŸ’š/g, lang==='nl' ? ' (uit genegenheid) ' : ' (expressing affection) ')
      .replace(/ğŸ‘/g, lang==='nl' ? ' (ten teken van instemming) ' : ' (signaling approval) ');

    if (Math.random() > 0.65) translated = starters[Math.floor(Math.random()*starters.length)] + translated;
    if (Math.random() > 0.72) translated = translated + enders[Math.floor(Math.random()*enders.length)];

    translated = translated.charAt(0).toUpperCase() + translated.slice(1);
    if (!/[.!?]$/.test(translated)) translated += '.';
    return translated;
  }

  // Translate Chat
  function translateChat() {
    const input = (chatInput.value || '').trim();
    if (!input) {
      setStatus('Paste or extract text first.', 'error');
      return;
    }

    const messages = parseImproved(input);
    
    console.log('ğŸ“Š Parsing results:', messages.length, 'messages found');

    if (messages.length === 0) {
      setStatus('âŒ No messages detected. Try switching parsing mode.', 'error');
      return;
    }

    let lang = document.getElementById('sourceLang').value || 'auto';
    
    if (lang === 'auto') {
      lang = detectLanguage(input);
      showDetectedLanguage(lang);
    } else {
      detectedLang.classList.remove('show');
    }

    setStatus(`âœ… Translated ${messages.length} messages to Medieval ${lang === 'nl' ? 'Dutch' : 'English'}!`, 'success');

    currentMessages = messages.map(m => ({
      time: m.time || '',
      content: m.content || '',
      medieval: translateOne(m.content || '', lang)
    }));
    
    // Final cleanup: filter out messages with OCR artifacts (but keep emojis!)
    currentMessages = currentMessages.filter(m => {
      const text = m.medieval.toLowerCase();
      
      // Skip if contains URLs or domains
      if (/github|crafty|\.io|\.com|http|www\./i.test(text)) return false;
      
      // Skip if contains weird artifact patterns (but NOT emojis)
      if (/\[%/.test(text)) return false; // [% artifact
      if (/=\s*\d+\s*\d+/.test(text)) return false; // "= 2 29"
      if (/^[^a-zA-Zâ¤ï¸ğŸ˜ŠğŸ‘]+$/.test(text)) return false; // Only symbols (but allow emojis)
      if (text.length < 5) return false;
      return true;
    });

    renderVisualChat(currentMessages);
  }

  function renderVisualChat(msgs) {
    chatArea.innerHTML = '';
    
    // Get selected platform style
    const platform = document.getElementById('platformStyle').value || 'whatsapp';
    
    // Apply platform class
    phoneMockup.className = 'phone-mockup show ' + platform;
    
    // Update header name based on platform
    const platformNames = {
      'whatsapp': 'Medieval Chat',
      'telegram': 'Medieval Channel',
      'messenger': 'Medieval Messenger',
      'instagram': 'Medieval DM',
      'snapchat': 'Medieval Snap',
      'tiktok': 'Medieval TikTok',
      'wechat': 'Medieval WeChat',
      'imessage': 'Messages',
      'discord': '#medieval-chat',
      'reddit': 'r/medieval'
    };
    
    document.querySelector('.phone-name').textContent = platformNames[platform] || 'Medieval Chat';
    
    // Get conversation pattern from user selection
    const pattern = document.getElementById('conversationPattern').value || 'alternate-them';
    
    for (let i = 0; i < msgs.length; i++) {
      const m = msgs[i];
      let who;
      
      // Determine sender based on selected pattern
      switch(pattern) {
        case 'all-them':
          who = 'them';
          break;
        case 'all-me':
          who = 'me';
          break;
        case 'alternate-me':
          who = (i % 2 === 0) ? 'me' : 'them';
          break;
        case 'alternate-them':
        default:
          who = (i % 2 === 0) ? 'them' : 'me';
          break;
      }
      
      const bubble = document.createElement('div');
      bubble.className = 'chat-bubble ' + who;
      
      const text = document.createElement('div');
      text.className = 'text';
      text.textContent = m.medieval;
      
      bubble.appendChild(text);
      
      if (m.time && platform !== 'discord' && platform !== 'reddit') {
        const time = document.createElement('div');
        time.className = 'time';
        time.textContent = m.time;
        bubble.appendChild(time);
      }
      
      chatArea.appendChild(bubble);
    }
    
    phoneMockup.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  // Download as Image
  async function downloadAsImage() {
    if (!currentMessages.length) {
      setStatus('Translate first!', 'error');
      return;
    }
    
    setStatus('ğŸ“¸ Creating screenshot...', 'info');
    
    try {
      const canvas = await html2canvas(phoneMockup, {
        backgroundColor: '#ffffff',
        scale: 2
      });
      
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'medieval-chat-screenshot.png';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        setStatus('âœ… Downloaded medieval screenshot!', 'success');
      });
    } catch (error) {
      console.error('Screenshot error:', error);
      setStatus('âŒ Could not create screenshot.', 'error');
    }
  }

  function copyMedieval() {
    if (!currentMessages.length) {
      setStatus('Translate first!', 'error');
      return;
    }
    let out = 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n   YE OLDE CHAT TRANSLATION\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';
    for (const m of currentMessages) {
      out += `${m.time ? '['+m.time+'] ' : ''}${m.medieval}\n\n`;
    }
    navigator.clipboard.writeText(out).then(() => {
      setStatus('âœ… Copied to clipboard!', 'success');
    }).catch(() => {
      setStatus('âŒ Could not copy.', 'error');
    });
  }

  function downloadMedieval() {
    if (!currentMessages.length) {
      setStatus('Translate first!', 'error');
      return;
    }
    let out = 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n        YE OLDE CHAT TRANSLATION\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';
    for (const m of currentMessages) {
      out += `${m.time ? '['+m.time+'] ' : ''}${m.medieval}\n\n`;
    }
    out += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n';

    const blob = new Blob([out], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'medieval-chat-translation.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus('âœ… Downloaded text file!', 'success');
  }
</script>

</body>
</html>
